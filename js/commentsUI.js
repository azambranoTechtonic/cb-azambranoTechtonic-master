function CommentModule (container) {  //  This is your CommentModule class constructor.  It is being passed a container parameter and has the URL that will eventually allow you to test your comment board through Postman.
// The last piece of the constructor simply assigns an empty array to this._commentState.  We are using Comment.call(this) to reset the context and inherit the context from the Comment class.
  Comment.call(this);
  this.$container = $('#show-comments');
  this.iconURL = 'https://www.keita-gaming.com/assets/game_logos_color/counterstrike-4af227b22ecc913945aa222f81811bfac8842d9d85a55b7e136e0d9c1413ec12.png';
  this._commentState = []
};

CommentModule.prototype = Object.create(Comment.prototype);

var theComment = function (oArgs)
{
  this.name = oArgs.name; //Required
  this.comment = oArgs.comment;
  return false;
};

//----------------------------------------------------------------------------------------------------------------
// Create a prototyped CommentModule method called init.  Inside of this function, you will want to call your _runGet function from Comment.  This is also where you will want to include any calls to your bindEvents(),
//just as you did in Phase 2 of the Library project.  You will need to use jQuery to find the container with the .comments class because it will be the only container affected by the methods in this module.
//It should look like this:  this.$commentShell = this.$container.find('.comments');

CommentModule.prototype.init = function()
{
    this._bindEvents();
    this._runGet();
    this.$commentShell = this.$container.find('.comments');
};

//----------------------------------------------------------------------------------------------------------------
// Create a prototyped CommentModule method called bindEvents.  It should not take any parameters, but should contain the following four events.
// 1. An event that handles submitting your comment using a single bind.  There is no need for proxy here.  Name it _handleSubmit.
// 2. An event that can run your _runGet() method from comment.js using a single bind.  There is no need for proxy here.
// 3. An event that utilizes delegation to delete a comment.  Name it _handleDelete.
// 4. An event to track the state of loaded comments on the document.  This is responsible for making sure that when a new comment goes in, it is prepending above the older comments.  Name it loadComments.

CommentModule.prototype._bindEvents = function ()
{
    $(".submit-comment").on("click", $.proxy(this._handleSubmit,this));

    $(".refresh-comments").on("click", $.proxy(this._runGet,this));

    //$(".delete-btn").on("click", function(){$(this)._handleDelete});
    $(document).on('click',".delete-btn",$.proxy(this._handleDelete, this));
    // $("#?").on("click", $.proxy(this.loadComments, this));
};

//----------------------------------------------------------------------------------------------------------------
// Create a prototyped CommentModule method called _handleSubmit.  Come up with the logic that will allow you to submit a comment leveraging your getFormData(), firePost(), and _addComment() methods.

CommentModule.prototype._handleSubmit = function ()
{
  var myComment = this.getFormData();

  this.firePost(myComment);

  // $('#comment-name').val('');
  // $('#comment-text').val('');

  $("#comment-form")[0].reset();

  this._runGet();

};


//----------------------------------------------------------------------------------------------------------------
// Create a prototyped CommentModule method called _handleDelete.  Come up with the logic that will allow you to delete a comment by leveraging your fireDelete() method.
//Thinking about current targets and autogenerated id's will prove useful here.

CommentModule.prototype._handleDelete = function (e)
{

    var deleteItem = e.target.closest("article").dataset.id;
    this.fireDelete(deleteItem);

    this._runGet();

};

//----------------------------------------------------------------------------------------------------------------
// Create a prototyped CommentModule method called getFormData.  Here, you will need to write the logic for pulling all of the values from the form into a new Object and looping through each entry
//to create a data object.  You will want to return the data object for later usage.  This should be very similar to how we did it in the addBooksModal of Phase 2 of the Library Project.

CommentModule.prototype.getFormData = function ()
{
    var myComment = new theComment({"name": $('#comment-name').val(),"comment": $('#comment-text').val()});
    return myComment;
};


//----------------------------------------------------------------------------------------------------------------
// Create a prototyped CommentModule method called loadComments.  You will need to write the logic to check if the array created in comment.js contains anything.
//If it does, you'll want to find a means for adding the values of any comments into the this.$commentShell.

CommentModule.prototype.loadComments = function (oResponse)
{

  if (oResponse.length > 0) {
    for (var i = oResponse.length - 1; i >= 0; i--) {
      this.$commentShell = this.$container.append(this.addComment(oResponse[i]));
    }
  }
};


//----------------------------------------------------------------------------------------------------------------
// Below is a prototyped CommentModule method that builds each comment and does not reuqire any changes.  We are providing this so that everyone's response displays in a standard way.
//Please do walk through it to ensure you understand what is happening.
CommentModule.prototype.addComment = function (oComment) {
    // console.log(oComment);
    return $('<article/>', {'id': 'comment-article','class': 'row', 'data-id': oComment._id}).append( //icon
      $('<div/>', {'class': 'col-md-2 col-sm-2 hidden-xs'}).append(
        $('<figure/>', {'class': 'thumbnail'}).append(
          $('<img/>', {'class': 'img-responsive', src: this.iconURL}),
          $('<figcaption/>', {'class': 'text-center', text: oComment.author})
        )
      ),//comment
      $('<div/>', {'class': 'col-md-10 col-sm-10'}).append(
        $('<div/>', {'class': 'panel panel-default arrow left'}).append(
          $('<div/>', {'class': 'panel-body'}).append(
            $('<header/>', {'class': 'text-left'}).append(
              $('<time/>', {'class': 'comment-date', text: new Date(oComment.pubDate)})
            ),
            $('<div/>', {'class': 'comment-post' }).append(
              $('<p/>', {text: oComment.comment })
            ),
            $('<p/>', {'class': 'text-right'}).append(
              $('<a/>', { 'class': 'btn btn-default btn-sm delete-btn', text:'delete', href: 'javascript:void(0);'})
            )
          )
        )
      )
    );

};

//This anonymous jQuery document ready function below will create a new CommentModule instance that is tied to the targeted jQuery container $('.comment-list').
//This is simply another way to limit the scope of this class to a specific container for better performance.  Doing so will ensure that our DOM tree traversal is only happening once, rather than over and over again.
// It caches down the bind events so that the jQuery objects they target don't have to be discovered redundantly.  It will also call the init function that will attach all of the bind events to the appropriate
//functionality.
$(function(){
  window.gCommentMod = new CommentModule($('.comment-list'));
  gCommentMod.init();
});
